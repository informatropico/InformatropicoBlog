'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require('babel-polyfill');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Youtube iframe generator
 */
var Youtube = function () {
  function Youtube(options, files) {
    _classCallCheck(this, Youtube);

    this.files = files;
    this.options = {
      suggested: options.suggested || true,
      showTitle: options.showTitle || true, // null, undefined default to true
      privacy: options.privacy || true,
      controls: options.controls || true,
      width: 560,
      height: 315
    };
    _extends(this.options, options);
  }

  /**
   * Parse the content
   * @param cb callback {Function}
   */


  _createClass(Youtube, [{
    key: 'parse',
    value: function parse(cb) {
      var _this = this;

      Object.keys(this.files).forEach(function (file) {
        var matches = _this._getYoutubes(_this.files[file].contents.toString());
        if (matches !== null) {
          matches.forEach(function (element) {
            var id = element.split('|')[1];
            var iframe = _this._createIframeBody(id, _this.options.width, _this.options.height);
            _this.files[file].contents = _this.files[file].contents.toString().replace(element, iframe);
          });
        }
      });
      cb();
    }

    /**
     * Return all youtube definitions within the body content
     * @param content
     * @returns {Array|{index: number, input: string}|*}
     * @private
     */

  }, {
    key: '_getYoutubes',
    value: function _getYoutubes(content) {
      return content.match(/youtube\|.\S*/g);
    }

    /**
     * Create a YouTube iframe
     * @param id the YouTube id
     * @param width iframe width
     * @param height iframe height
     * @returns {string} iframe as string
     * @private
     */

  }, {
    key: '_createIframeBody',
    value: function _createIframeBody(id, width, height) {
      var url = void 0;
      if (this.options.privacy) {
        url = 'https://www.youtube-nocookie.com/embed/' + id;
      } else {
        url = 'https://www.youtube.com/embed/' + id;
      }
      url += this.options.suggested ? '?rel=0&amp;' : '?';
      url += this.options.showTitle ? '&amp;showinfo=0' : '';
      url += this.options.controls ? '&amp;controls=0' : '';
      var iframe = '<iframe width=\'' + width + '\' height=\'' + height + '\' src=\'' + url + '\' frameborder=\'0\' allowfullscreen></iframe>';
      return iframe;
    }
  }]);

  return Youtube;
}();

/**
 * Metalsmith plugin to render Youtube Video
 * @param {Object} options (optional)
 * @return {Function}
 */


function plugin(_options) {
  var options = _options || {};
  return function (files, metalsmith, done) {
    var app = new Youtube(options, files);
    app.parse(function () {
      done();
    });
  };
}

/**
* Expose `plugin`.
*/
exports = module.exports = plugin;